
int Fun4All_MCEventGen(
                       const int nEvents = 1000,
                       const char * outputFile = "G4MCEventGen.root"
                       )
{
  //===============
  // Input options
  //===============

  // read files in HepMC format (typically output from event generators like hijing or pythia)
  const bool readhepmc = false; // read HepMC files

  // read files in EICTree format generated by eicsmear package
  const bool readeictree = false;

  // Use particle generator Pythia 8
  const bool runpythia8 = false;

  // Use particle generator Pythia 6
  const bool runpythia6 = false;

  // Use particle generator HEPGen
  const bool runhepgen = true;

  // Use particle generator Sartre
  const bool runsartre = false;

  // Other options
  bool do_dst_compress = true;

  // Option to convert DST to human command readable TTree for quick poke around the outputs
  bool do_DSTReader = true;

  // Option to run DIS analysis module- need to compile analysis library first!
  bool do_analysis_DIS = false;

  // Option to save DST output file
  bool do_DSTOutput = false;

  //---------------
  // Load libraries
  //---------------
  gSystem->Load("libfun4all.so");
  gSystem->Load("libg4detectors.so");
  gSystem->Load("libphhepmc.so");
  gSystem->Load("libg4eval.so");

  //---------------
  // Fun4All server
  //---------------
  Fun4AllServer *se = Fun4AllServer::instance();
  //  se->Verbosity(0); // uncomment for batch production running with minimal output messages
  se->Verbosity(Fun4AllServer::VERBOSITY_SOME); // uncomment for some info for interactive running
  // just if we set some flags somewhere in this macro
  recoConsts *rc = recoConsts::instance();
  // By default every random number generator uses
  // PHRandomSeed() which reads /dev/urandom to get its seed
  // if the RANDOMSEED flag is set its value is taken as seed
  // You can either set this to a random value using PHRandomSeed()
  // which will make all seeds identical (not sure what the point of
  // this would be:
  //  rc->set_IntFlag("RANDOMSEED",PHRandomSeed());
  // or set it to a fixed value so you can debug your code
  // rc->set_IntFlag("RANDOMSEED", 12345);

  /* Set world parameters in reco consts */
  rc->set_FloatFlag("WorldSizex", 1000.);
  rc->set_FloatFlag("WorldSizey", 1000.);
  rc->set_FloatFlag("WorldSizez", 1000.);
  rc->set_CharFlag("WorldShape", "G4Tubs");


  //-----------------
  // Event generation
  //-----------------

  if (readhepmc)
    {
      // this module is needed to read the HepMC records into our G4 sims
      // but only if you read HepMC input files
      HepMCNodeReader *hr = new HepMCNodeReader();
      se->registerSubsystem(hr);
    }
  else if (readeictree)
    {
      // this module is needed to read the EICTree style records into our G4 sims
      ReadEICFiles *eicr = new ReadEICFiles();
      eicr->OpenInputFile("data/eictree_milou_dvcs_10x250.root");

      se->registerSubsystem(eicr);

      HepMCNodeReader *hr = new HepMCNodeReader();
      se->registerSubsystem(hr);
    }
  else if (runpythia8)
    {
      gSystem->Load("libPHPythia8.so");

      PHPythia8* pythia8 = new PHPythia8();
      // see coresoftware/generators/PHPythia8 for example config
      pythia8->set_config_file("phpythia8.cfg");
      se->registerSubsystem(pythia8);

      HepMCNodeReader *hr = new HepMCNodeReader();
      se->registerSubsystem(hr);
    }
  else if (runpythia6)
    {
      gSystem->Load("libPHPythia6.so");

      PHPythia6 *pythia6 = new PHPythia6();
      pythia6->set_config_file("config/phpythia6_ep.cfg");
      se->registerSubsystem(pythia6);

      HepMCNodeReader *hr = new HepMCNodeReader();
      se->registerSubsystem(hr);
    }
  else if (runhepgen)
    {
      gSystem->Load("libsHEPGen.so");

      sHEPGen *hepgen = new sHEPGen();
      hepgen->set_datacard_file("config/hepgen_eic_dvcs.data");
      hepgen->set_momentum_electron(-10);
      hepgen->set_momentum_hadron(250);
      se->registerSubsystem(hepgen);

      HepMCNodeReader *hr = new HepMCNodeReader();
      se->registerSubsystem(hr);
    }
  else if (runsartre)
    {
      // see coresoftware/generators/PHSartre/README for setup instructions
      // before running:
      // setenv SARTRE_DIR /opt/sphenix/core/sartre-1.20_root-5.34.36
      gSystem->Load("libPHSartre.so");

      PHSartre* mysartre = new PHSartre();
      // see coresoftware/generators/PHSartre for example config
      mysartre->set_config_file("config/sartre_ep.cfg");

      // particle trigger to enhance forward J/Psi -> ee
      //PHSartreParticleTrigger* pTrig = new PHSartreParticleTrigger("MySartreTrigger");
      //pTrig->AddParticles(-11);
      //pTrig->SetEtaHighLow(4.0,1.4);
      //pTrig->SetEtaHighLow(1.0,-1.1);  // central arm
      //pTrig->PrintConfig();
      //mysartre->register_trigger((PHSartreGenTrigger *)pTrig);
      se->registerSubsystem(mysartre);

      HepMCNodeReader *hr = new HepMCNodeReader();
      se->registerSubsystem(hr);
    }
  else
    {
      // toss low multiplicity dummy events
      PHG4SimpleEventGenerator *gen = new PHG4SimpleEventGenerator();
      //gen->add_particles("e-",5); // mu+,e+,proton,pi+,Upsilon
      //gen->add_particles("e+",5); // mu-,e-,anti_proton,pi-
      gen->add_particles("pi-",1); // mu-,e-,anti_proton,pi-
      if (readhepmc) {
        gen->set_reuse_existing_vertex(true);
        gen->set_existing_vertex_offset_vector(0.0,0.0,0.0);
      } else {
        gen->set_vertex_distribution_function(PHG4SimpleEventGenerator::Uniform,
                                              PHG4SimpleEventGenerator::Uniform,
                                              PHG4SimpleEventGenerator::Uniform);
        gen->set_vertex_distribution_mean(0.0,0.0,0.0);
        gen->set_vertex_distribution_width(0.0,0.0,5.0);
      }
      gen->set_vertex_size_function(PHG4SimpleEventGenerator::Uniform);
      gen->set_vertex_size_parameters(0.0,0.0);
      gen->set_eta_range(1.4, 3.0);
      //gen->set_eta_range(3.0, 3.0); //EICDetector FWD
      gen->set_phi_range(-1.0*TMath::Pi(), 1.0*TMath::Pi());
      //gen->set_phi_range(TMath::Pi()/2-0.1, TMath::Pi()/2-0.1);
      gen->set_p_range(30.0, 30.0);
      gen->Embed(1);
      gen->Verbosity(0);
      se->registerSubsystem(gen);
    }

  /* register optional analysis module */
  if (do_analysis_DIS)
    {
      gSystem->Load("libeicana.so");
      DISKinematics *dis = new DISKinematics("dis_evalshep.root");
      se->registerSubsystem(dis);
    }


  //-----------------
  // Reco and Truth
  //-----------------
  PHG4Reco* g4Reco = new PHG4Reco();
  PHG4TruthSubsystem *truth = new PHG4TruthSubsystem();
  g4Reco->registerSubsystem(truth);
  se->registerSubsystem( g4Reco );


  /* write DSTReader human readable output tree */
  if (do_DSTReader)
    {
      // save a comprehensive  evaluation file
      PHG4DSTReader* ana = new PHG4DSTReader(string(outputFile) + string("_DSTReader.root"));
      ana->set_save_particle(true);
      ana->set_load_all_particle(false);
      ana->set_load_active_particle(true);
      ana->set_save_vertex(true);

      se->registerSubsystem(ana);
    }


  /* Write DST output file */
  if ( do_DSTOutput )
    {
      Fun4AllDstOutputManager *out = new Fun4AllDstOutputManager("DSTOUT", outputFile);
      se->registerOutputManager(out);
    }

  if (nEvents <= 0 && !readhepmc)
    {
      cout << "using 0 for number of events is a bad idea when using particle generators" << endl;
      cout << "it will run forever, so I just return without running anything" << endl;
      return;
    }
  else
    {
      se->run(nEvents);

      se->End();
      std::cout << "All done" << std::endl;
      delete se;
      gSystem->Exit(0);
    }

}


void
G4Cmd(const char * cmd)
{
  Fun4AllServer *se = Fun4AllServer::instance();
  PHG4Reco *g4 = (PHG4Reco *) se->getSubsysReco("PHG4RECO");
  g4->ApplyCommand(cmd);
}
